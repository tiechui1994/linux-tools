#!/bin/bash

#----------------------------------------------------
# File: sysvinit
# Contents: sysvinit
# Date: 19-5-26
#----------------------------------------------------

#---------------------------------------------------------------------------------------------------
# 什么是init系统, init系统的历史和现状
#
# Linux操作系统的启动首先是从BIOS开始, 接下进入bootloader, 由bootloader载入内核, 进入内核初始化. 内核初始化的最后
# 一步是启动pid为1的init进程. 这个进程是系统的第一个进程. 它负责产生其他所有用户进程.
#
# init系统能够定义,管理和控制init进程的行为. 它负责组织和运行许多独立的或相关的初始化工作(因此被称为init系统), 从而让
# 计算机系统进入某种用户预定的运行模式.
#
# 仅仅将内核运行起来是毫无实际用途的, 必须又init系统将系统带入可操作状态. 比如启动外壳shell后, 便可以进行人机交互,或者
# 是启动X图形系统以便提供更佳的人机界面, 更加高效的完成任务. 这里, 字符界面的shell或者X系统都是一种预设的运行模式.
#
# 大多数Linux发行版的init系统是和System V相兼容的, 被称为sysvinit. Ubuntu和RHEL采用upstart替代了传统的sysvinit.
# 而Fedora15之后使用了一个被称为systemd的新的init系统.
#---------------------------------------------------------------------------------------------------


#---------------------------------------------------------------------------------------------------
# Sysvinit
#
# Sysvinit是System V风格的init系统, 它源于System V系列UNIX. 它提供了比BSD风格init系统更高的灵活性. 是已经风行了
# 几十年的UNIX init系统, 一直被各类Linux发行版所采用.
#
#
#
# 运行级别
#
# Sysvinit使用术语runlevel来定义"预定义的运行模式". Sysvinit检查'/etc/inittab'文件是否包含有'initdefault'项,
# 这告诉init系统是否有一个默认运行模式. 如果没有默认的运行模式, 那么用户将进入系统控制台, 手动决定进入何种运行模式.
#
# Sysvinit中运行模式描述了系统各种预定的运行模式. 通常会有8种运行模式, 即运行模式0到6和S. 每种Linux发行版对运行模式的
# 定义都不太一样. 但0,1,6却是一致的:
# - 0 关机
# - 1 单用户模式
# - 6 重启
#
# 通常在/etc/inittab文件中定义了各种运行模式的工作范围. 比如, RedHat定义了runlevel 3和5. 运行模式3将系统初始化为字
# 符界面的shell模式; 运行模式5将系统初始化为GUI模式.
#
#
#
# Sysvinit运行顺序
#
# Sysvinit巧妙地运用脚本, 文件命名规则和软连接来实现不同的runlevel. 首先, Sysvinit需要读取/etc/inittab文件. 分析
# 这个文件的内容, 它获取得以下一些配置信息:
# - 系统需要进入的runlevel
# - 捕获组合键的定义
# - 定义电源 fail/restore 脚本
# - 启动getty和虚拟控制台
#
# 得到配置信息之后, Sysvinit顺序地执行以下步骤, 从而将系统初始化为预定的runlevel X.
# - /etc/rc.d/rc.sysint
# - /etc/rc.d/rc 和 /etc/rc.d/rcX.d/ (X代表运行级别0-6)
# - /etc/rc.d/rc.local
# - X Display Manager (如果需要的话)
#
# 首先, 运行rc.sysinit以便执行一些重要的系统初始化任务. 在REHL5(REHL6使用的是upstart)中, rc.sysinit主要完成以下
# 工作:
# - 激活udev和selinux
# - 设置定义在/etc/sysctl.conf中的内核参数
# - 设置系统时钟
# - 加载keymaps
# - 挂载交换分区
# - 设置主机名(hostname)
# - 根分区检查和remount
# - 激活RAID和LVM设置
# - 开启磁盘配额
# - 检查并挂载所有文件系统
# - 清除过期的locks和pid文件
#
# 完成上述工作之后, sysvinit开始运行/etc/rc.d/rc 脚本. 根据不同的runlevel, rc脚本将打开对于该runlevel的rcX.d目
# 录, 找到并运行存放在该目录下所有启动脚本. 每个runlevel X都有一个这样的目录. 目录名称为 /etc/rc.d/rcX.d.
#
# 在这些目录下存放着很多不同的脚本. 文件名以S开头的脚本就是启动时应该执行的脚本, S后面跟的数字定义了这些脚本的执行顺序.
# 在/etc/rc.d/rcX.d目录下的脚本其实都是一些软连接文件, 真实的脚本文件存放在/etc/init.d目录下.
#
# 当所有的初始化脚本执行完毕, Sysvinit运行/etc/rc.d/rc.local脚本. rc.local是Linux留给用户进行个性化设置的地方.
#
#
#
# Sysvinit和系统关闭
#
# Sysvinit不仅负责初始化系统吗还需要负责关闭系统. 在系统关闭时, 为了保证数据的一致性, 需要小心地按顺序进行结束和清理工
# 作.
#
# 这种顺序的控制也是依靠/etc/rc.d/rcX.d目录下的所有脚本的命名规则来控制的, 在该目录下所有以K开头的脚本都将在关闭系统时
# 调用, 字母K之后的数字定义了它们是执行顺序.
#
#
#
# Sysvinit的管理和控制功能
#
# 原始的Sysvinit软件包包含了一系列的控制启动, 运行和关闭其他程序的工具.
#
# halt: 停止系统
#
# init: Sysvinit本身的init进程实体, 以pid为1的身份运行, 是所有用户进程的父进程. 最主要的作用是启动过程中使用文件
# /etc/inittab来创建进程.
#
# killall5: System V的killall命令. 向除自己的会话(session)进程外的其他进程发出信号, 所以不能杀死当前使用的shell
#
# last: 回溯/var/log/wtmp文件, 显示自从这个文件建立以来, 所有用户的登录情况
#
# mesg: 控制其他用户对用户终端的访问.
#
# pidof: 找出程序的进程号pid, 输出到标准输出设备
#
# poweroff: 等于shutdown -h -p, 或者telinit 0. 关闭系统并切断电源.
#
# reboot: 等于 shutdown -r, 或者 telinit 6. 重启系统
#
# shutdown: 以一种安全的方式终止系统, 所有正在登录的用户都会收到系统将要终止通知, 并且不准新的登录
#
# telinit: 实际上是init的一个连接, 用来向init传送单字符参数和信号.
#
# runlevel: 把当前的系统运行级别输出到标准设备
#
#
#
# Sysvinit小结
#
# Sysvinit的优点是概念简单. Service开发人员只需要编写启动和停止脚本, 概念非常清除; 将service添加/删除到某个runlevel
# 时, 只需要执行一些创建/删除软链接文件的基本操作;
#
# 其次, Sysvinit的另一个优点是确定的执行顺序: 脚本严格按照启动数字的大小顺序执行, 一个执行完毕再执行下一个, 这非常有益
# 于错误排查. Upstart和Systemd支持并发启动, 导致没有人可以确定地了解具体的启动顺序, 排错不易.
#
#---------------------------------------------------------------------------------------------------